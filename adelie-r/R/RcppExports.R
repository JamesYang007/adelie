# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' ISTA solver.
#'
#' @param   L       vector representing a diagonal PSD matrix.
#'                  Must have max(L + s) > 0. 
#'                  L.size() <= buffer1.size().
#' @param   v       any vector.  
#' @param   l1      L2-norm penalty. Must be >= 0.
#' @param   l2      L2 penalty. Must be >= 0.
#' @param   tol         Newton's method tolerance of closeness to 0.
#' @param   max_iters   maximum number of iterations of Newton's method.
#' @export
ista_solver <- function(L, v, l1, l2, tol, max_iters) {
    .Call(`_adelie_ista_solver`, L, v, l1, l2, tol, max_iters)
}

#' FISTA solver.
#'
#' @param   L       vector representing a diagonal PSD matrix.
#'                  Must have max(L + s) > 0. 
#'                  L.size() <= buffer1.size().
#' @param   v       any vector.  
#' @param   l1      L2-norm penalty. Must be >= 0.
#' @param   l2      L2 penalty. Must be >= 0.
#' @param   tol         Newton's method tolerance of closeness to 0.
#' @param   max_iters   maximum number of iterations of Newton's method.
#' @export
fista_solver <- function(L, v, l1, l2, tol, max_iters) {
    .Call(`_adelie_fista_solver`, L, v, l1, l2, tol, max_iters)
}

#' FISTA solver with adaptive restart.
#'
#' @param   L       vector representing a diagonal PSD matrix.
#'                  Must have max(L + s) > 0. 
#'                  L.size() <= buffer1.size().
#' @param   v       any vector.  
#' @param   l1      L2-norm penalty. Must be >= 0.
#' @param   l2      L2 penalty. Must be >= 0.
#' @param   tol         Newton's method tolerance of closeness to 0.
#' @param   max_iters   maximum number of iterations of Newton's method.
#' @export
fista_adares_solver <- function(L, v, l1, l2, tol, max_iters) {
    .Call(`_adelie_fista_adares_solver`, L, v, l1, l2, tol, max_iters)
}

#' @export
group_basil_cov__ <- function(X, y, groups, group_sizes, alpha, penalty, user_lmdas_, max_n_lambdas, n_lambdas_iter, use_screen_rule, do_early_exit, verbose_diagnostic, delta_screen_size, max_screen_size, max_n_cds, tol, rsq_slope_tol, rsq_curv_tol, newton_tol, newton_max_iters, min_ratio, n_threads) {
    .Call(`_adelie_group_basil_cov__`, X, y, groups, group_sizes, alpha, penalty, user_lmdas_, max_n_lambdas, n_lambdas_iter, use_screen_rule, do_early_exit, verbose_diagnostic, delta_screen_size, max_screen_size, max_n_cds, tol, rsq_slope_tol, rsq_curv_tol, newton_tol, newton_max_iters, min_ratio, n_threads)
}

#' @export
group_basil_naive__ <- function(X, y, groups, group_sizes, alpha, penalty, user_lmdas_, max_n_lambdas, n_lambdas_iter, use_screen_rule, do_early_exit, verbose_diagnostic, delta_screen_size, max_screen_size, max_n_cds, tol, rsq_slope_tol, rsq_curv_tol, newton_tol, newton_max_iters, min_ratio, n_threads) {
    .Call(`_adelie_group_basil_naive__`, X, y, groups, group_sizes, alpha, penalty, user_lmdas_, max_n_lambdas, n_lambdas_iter, use_screen_rule, do_early_exit, verbose_diagnostic, delta_screen_size, max_screen_size, max_n_cds, tol, rsq_slope_tol, rsq_curv_tol, newton_tol, newton_max_iters, min_ratio, n_threads)
}

#' Newton solver
#'
#' @param   L       vector representing a diagonal PSD matrix.
#'                  Must have max(L + s) > 0. 
#'                  L.size() <= buffer1.size().
#' @param   v       any vector.  
#' @param   l1      L2-norm penalty. Must be >= 0.
#' @param   l2      L2 penalty. Must be >= 0.
#' @param   tol         Newton's method tolerance of closeness to 0.
#' @param   max_iters   maximum number of iterations of Newton's method.
#' @export
newton_solver <- function(L, v, l1, l2, tol, max_iters) {
    .Call(`_adelie_newton_solver`, L, v, l1, l2, tol, max_iters)
}

#' Newton-ABS solver
#'
#' @param   L       vector representing a diagonal PSD matrix.
#'                  Must have max(L + s) > 0. 
#'                  L.size() <= buffer1.size().
#' @param   v       any vector.  
#' @param   l1      L2-norm penalty. Must be >= 0.
#' @param   l2      L2 penalty. Must be >= 0.
#' @param   tol         Newton's method tolerance of closeness to 0.
#' @param   max_iters   maximum number of iterations of Newton's method.
#' @export
newton_abs_solver <- function(L, v, l1, l2, tol, max_iters) {
    .Call(`_adelie_newton_abs_solver`, L, v, l1, l2, tol, max_iters)
}

#' Newton solver with more information.
#'
#' @param   L       vector representing a diagonal PSD matrix.
#'                  Must have max(L + s) > 0. 
#'                  L.size() <= buffer1.size().
#' @param   v       any vector.  
#' @param   l1      L2-norm penalty. Must be >= 0.
#' @param   l2      L2 penalty. Must be >= 0.
#' @param   tol         Newton's method tolerance of closeness to 0.
#' @param   max_iters   maximum number of iterations of Newton's method.
#' @export
newton_abs_debug_solver <- function(L, v, l1, l2, tol, max_iters, smart_init = TRUE) {
    .Call(`_adelie_newton_abs_debug_solver`, L, v, l1, l2, tol, max_iters, smart_init)
}

#' Computes the group-lasso objective.
#' 
#' @param   A       any square (p, p) matrix. 
#' @param   r       any vector (p,).
#' @param   groups  vector defining group beginning indices.
#' @param   group_sizes vector defining group sizes.
#' @param   alpha       elastic net proportion.
#' @param   penalty penalty factor for each group.
#' @param   lmda    group-lasso regularization.
#' @param   beta    coefficient vector.
#' @export
objective <- function(A, r, groups, group_sizes, alpha, penalty, lmda, beta) {
    .Call(`_adelie_objective`, A, r, groups, group_sizes, alpha, penalty, lmda, beta)
}

